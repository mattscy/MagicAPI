{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"im not sure what to put here please see the magic page","title":"Home"},{"location":"api/hitdetails/","text":"HitDetails A HitDetails instance is given whenever you detect another object, such as through the Touched event. The purpose of this class is to let you check the details of an object that you have detected before you decide to pay for a reference to it. If you do decide that you want a reference, you can pay for the object with the Magic:GetObject or Magic:GetLingeringObject methods. For balancing reasons, HitDetails instances expire as soon as there is any yield, so you can't wait before getting an object from a HitDetails . Functions bool IsEnemy() bool IsFriendly() bool IsTerrain() bool IsMine() bool IsType(string type)","title":"HitDetails"},{"location":"api/hitdetails/#hitdetails","text":"A HitDetails instance is given whenever you detect another object, such as through the Touched event. The purpose of this class is to let you check the details of an object that you have detected before you decide to pay for a reference to it. If you do decide that you want a reference, you can pay for the object with the Magic:GetObject or Magic:GetLingeringObject methods. For balancing reasons, HitDetails instances expire as soon as there is any yield, so you can't wait before getting an object from a HitDetails .","title":"HitDetails"},{"location":"api/hitdetails/#functions","text":"bool IsEnemy() bool IsFriendly() bool IsTerrain() bool IsMine() bool IsType(string type)","title":"Functions"},{"location":"api/magic/","text":"Magic The Magic class is the core class of the system. It manages your mana and provides all the functions that you can use to manipulate objects in the game. Mana is a measurement of your magical potential, similarly to how stamina is a measurement of physical potential. You can spend mana to achieve all kinds of magical effects. Most of the functions in the Magic class cost an amount of mana depending on the arguments that you give. For example, the Magic:Fling function can be used to fling an object by temporarily setting its velocity. However, using a velocity with a larger magnitude will cost more mana. It is also important keep in mind that using functions on enemy objects is often more expensive than using the same functions on friendly objects. This class also lets you retrieve the Character object that represents your character using the Mana:GetMyCharacter function. Your script will only run after your character is completely loaded every time you respawn, so you don't have to worry about waiting for anything. Functions Character GetMyCharacter() Returns an object that represents your character. Object CreateObject (string name, [ Object relativeTo, (Vector3|CFrame) offset]) Creates a new object from a name. Object GetObject ( HitDetails hitObjectDetails) Returns an object from a HitDetails that expires immediately. Subscription , Object GetLingeringObject ( HitDetails hitObjectDetails) Returns an object from a HitDetails that expires after the subscription is cancelled. void ChargeDamage( Object object, int amount) Charges an object with an amount of damage. Subscription Follow( Object object, Object target, (Vector3|CFrame) offset) Makes an object follow a target object at a constant offset. Subscription SetVelocity( Object object, Vector3 velocity) Gives an object a constant velocity until the subscription is cancelled. Subscription Watch( Object pointing, ( Object |Mouse) target, [(Vector3|CFrame) targetOffset]) Makes an object point towards another object until the subscription is cancelled. void LookAt( Object pointing, ( Object |Mouse) target, [(Vector3|CFrame) targetOffset]) Makes an object point towards another object. void Fling ( Object object, Vector3 velocity, [float duration]) Gives an object an instantaneous thrust that overrides all other forces until the duration passes. Subscription , RBXScriptSignal -> (bool entered, HitDetails detectedDetails) GetSphereDetectionSignal ( Object detecting, float radius) Returns an event that fires when something enters the radius of an object until the subscription is cancelled. void Overdrive(bool enabled) Allows health to be spent as mana when enabled. Events ManaChanged -> (int currentMana, int maxMana)","title":"Magic"},{"location":"api/magic/#magic","text":"The Magic class is the core class of the system. It manages your mana and provides all the functions that you can use to manipulate objects in the game. Mana is a measurement of your magical potential, similarly to how stamina is a measurement of physical potential. You can spend mana to achieve all kinds of magical effects. Most of the functions in the Magic class cost an amount of mana depending on the arguments that you give. For example, the Magic:Fling function can be used to fling an object by temporarily setting its velocity. However, using a velocity with a larger magnitude will cost more mana. It is also important keep in mind that using functions on enemy objects is often more expensive than using the same functions on friendly objects. This class also lets you retrieve the Character object that represents your character using the Mana:GetMyCharacter function. Your script will only run after your character is completely loaded every time you respawn, so you don't have to worry about waiting for anything.","title":"Magic"},{"location":"api/magic/#functions","text":"Character GetMyCharacter() Returns an object that represents your character. Object CreateObject (string name, [ Object relativeTo, (Vector3|CFrame) offset]) Creates a new object from a name. Object GetObject ( HitDetails hitObjectDetails) Returns an object from a HitDetails that expires immediately. Subscription , Object GetLingeringObject ( HitDetails hitObjectDetails) Returns an object from a HitDetails that expires after the subscription is cancelled. void ChargeDamage( Object object, int amount) Charges an object with an amount of damage. Subscription Follow( Object object, Object target, (Vector3|CFrame) offset) Makes an object follow a target object at a constant offset. Subscription SetVelocity( Object object, Vector3 velocity) Gives an object a constant velocity until the subscription is cancelled. Subscription Watch( Object pointing, ( Object |Mouse) target, [(Vector3|CFrame) targetOffset]) Makes an object point towards another object until the subscription is cancelled. void LookAt( Object pointing, ( Object |Mouse) target, [(Vector3|CFrame) targetOffset]) Makes an object point towards another object. void Fling ( Object object, Vector3 velocity, [float duration]) Gives an object an instantaneous thrust that overrides all other forces until the duration passes. Subscription , RBXScriptSignal -> (bool entered, HitDetails detectedDetails) GetSphereDetectionSignal ( Object detecting, float radius) Returns an event that fires when something enters the radius of an object until the subscription is cancelled. void Overdrive(bool enabled) Allows health to be spent as mana when enabled.","title":"Functions"},{"location":"api/magic/#events","text":"ManaChanged -> (int currentMana, int maxMana)","title":"Events"},{"location":"api/magic/CreateObject/","text":"CreateObject This function finds an instance in your \"Objects\" folder with the given name and turns it into an object. The type of instance will determine which kind of object it becomes: Instances that are a BasePart will return an object of the Part class. Instances that are a Model will Return an object of the Character class if the instance contains a Humanoid . Return an object of the Model class otherwise. The Part , Character and Model classes all inherit from the Object class. Parameters Name Type Default Description name string The name of the object that you want to create, which will be found in your \"Objects\" folder. relativeTo Object Magic:GetMyCharacter() The new object will be created at an offset from this object. offset Vector3 or CFrame An offset that places the object in front of relativeTo . Determines how far away the newly created object is placed from relativeTo . The magnitude will be clamped at 50. Returns Return Type Summary Object The object that was created from the instance. Mana Cost Creating any object has a base cost of 50 mana. As well as this, creating larger objects will be more expensive, although objects with a size that is less than 1 will not be cheaper than objects with a size of 1. Objects that are created further away than 20 studs from relativeTo also have an additional cost. local cost = 50 + math.max ( 1 , object : GetSize ()) * 10 local offsetDistance = 0 if offset then if type ( offset ) == \"Vector3\" then offsetDistance = offset . Magnitude elseif type ( offset ) == \"CFrame\" then offsetDistance = offset . Position . Magnitude end end cost += math.max ( 0 , offsetDistance - 20 ) * 10 return cost","title":"CreateObject"},{"location":"api/magic/CreateObject/#createobject","text":"This function finds an instance in your \"Objects\" folder with the given name and turns it into an object. The type of instance will determine which kind of object it becomes: Instances that are a BasePart will return an object of the Part class. Instances that are a Model will Return an object of the Character class if the instance contains a Humanoid . Return an object of the Model class otherwise. The Part , Character and Model classes all inherit from the Object class.","title":"CreateObject"},{"location":"api/magic/CreateObject/#parameters","text":"Name Type Default Description name string The name of the object that you want to create, which will be found in your \"Objects\" folder. relativeTo Object Magic:GetMyCharacter() The new object will be created at an offset from this object. offset Vector3 or CFrame An offset that places the object in front of relativeTo . Determines how far away the newly created object is placed from relativeTo . The magnitude will be clamped at 50.","title":"Parameters"},{"location":"api/magic/CreateObject/#returns","text":"Return Type Summary Object The object that was created from the instance.","title":"Returns"},{"location":"api/magic/CreateObject/#mana-cost","text":"Creating any object has a base cost of 50 mana. As well as this, creating larger objects will be more expensive, although objects with a size that is less than 1 will not be cheaper than objects with a size of 1. Objects that are created further away than 20 studs from relativeTo also have an additional cost. local cost = 50 + math.max ( 1 , object : GetSize ()) * 10 local offsetDistance = 0 if offset then if type ( offset ) == \"Vector3\" then offsetDistance = offset . Magnitude elseif type ( offset ) == \"CFrame\" then offsetDistance = offset . Position . Magnitude end end cost += math.max ( 0 , offsetDistance - 20 ) * 10 return cost","title":"Mana Cost"},{"location":"api/magic/Fling/","text":"Magic:Fling Fling can be used to set the velocity of an object instantaneously rather than applying a continuous force. If another continuous force is being applied to the object (e.g. if the object was being moved with Magic:SetVelocity ), setting the velocity in this way would ordinarily do nothing. However, the duration parameter can be used to override such other forces for an amount of time. Parameters Name Type Default Description object Object The object you want to fling. velocity Vector3 The velocity you want the object to have. duration float 0 The duration that you want to override all other forces for. Must be between 0 and 10. Mana Cost Larger objects and higher velocities cost more mana. Flinging enemy objects is 10x more expensive, and the duration parameter only affects the cost when flinging enemy objects. local cost = object : GetSize () * velocity . Magnitude * 0.1 if object : IsEnemy () then cost = cost * 10 + duration * 50 end return cost","title":"Magic:Fling"},{"location":"api/magic/Fling/#magicfling","text":"Fling can be used to set the velocity of an object instantaneously rather than applying a continuous force. If another continuous force is being applied to the object (e.g. if the object was being moved with Magic:SetVelocity ), setting the velocity in this way would ordinarily do nothing. However, the duration parameter can be used to override such other forces for an amount of time.","title":"Magic:Fling"},{"location":"api/magic/Fling/#parameters","text":"Name Type Default Description object Object The object you want to fling. velocity Vector3 The velocity you want the object to have. duration float 0 The duration that you want to override all other forces for. Must be between 0 and 10.","title":"Parameters"},{"location":"api/magic/Fling/#mana-cost","text":"Larger objects and higher velocities cost more mana. Flinging enemy objects is 10x more expensive, and the duration parameter only affects the cost when flinging enemy objects. local cost = object : GetSize () * velocity . Magnitude * 0.1 if object : IsEnemy () then cost = cost * 10 + duration * 50 end return cost","title":"Mana Cost"},{"location":"api/magic/GetLingeringObject/","text":"Magic:GetLingeringObject This function is an alternative to the Magic:GetObject function that allows for a continuous reference to the object that you retrieve from a HitDetails . The reference to the object will expire once the returned subscription expires. Parameters Name Type Default Description hitObjectDetails HitDetails The HitDetails of the object that you have detected. Returns Return Type Summary Subscription When this subscription is cancelled, the returned object will expire. Object The object that you retrieve from the HitDetails . This object will expire after the returned subscription is cancelled. Mana Cost There is no immediate cost for getting a lingering object. The cost rate of the subscription is determined by the type of the detected object. local cost = 0 local subCost if hitObjectDetails : IsMine () then subCost = 0 elseif hitObjectDetails : IsFriendly () then subCost = 1 elseif hitObjectDetails : IsEnemy () then subCost = 10 end return cost , subCost","title":"Magic:GetLingeringObject"},{"location":"api/magic/GetLingeringObject/#magicgetlingeringobject","text":"This function is an alternative to the Magic:GetObject function that allows for a continuous reference to the object that you retrieve from a HitDetails . The reference to the object will expire once the returned subscription expires.","title":"Magic:GetLingeringObject"},{"location":"api/magic/GetLingeringObject/#parameters","text":"Name Type Default Description hitObjectDetails HitDetails The HitDetails of the object that you have detected.","title":"Parameters"},{"location":"api/magic/GetLingeringObject/#returns","text":"Return Type Summary Subscription When this subscription is cancelled, the returned object will expire. Object The object that you retrieve from the HitDetails . This object will expire after the returned subscription is cancelled.","title":"Returns"},{"location":"api/magic/GetLingeringObject/#mana-cost","text":"There is no immediate cost for getting a lingering object. The cost rate of the subscription is determined by the type of the detected object. local cost = 0 local subCost if hitObjectDetails : IsMine () then subCost = 0 elseif hitObjectDetails : IsFriendly () then subCost = 1 elseif hitObjectDetails : IsEnemy () then subCost = 10 end return cost , subCost","title":"Mana Cost"},{"location":"api/magic/GetObject/","text":"Magic:GetObject This function allows you to convert a HitDetails into an object that you can interact with. The object returned from this function will usually expire immediately after any yield (the exception to this is the HitDetails from the Magic:GetSphereDetectionSignal function). This means that any effect that you want to apply to the object must be applied immediately after using Magic:GetObject . If you instead want a continuous reference to an object, consider using the Magic:GetLingeringObject function instead. Parameters Name Type Default Description hitObjectDetails HitDetails The HitDetails of the object that you have detected. Returns Return Type Summary Object The object that you retrieve from the HitDetails . This object will expire after any yield. Mana Cost This function does not currently cost any mana. local cost = 0 return cost","title":"Magic:GetObject"},{"location":"api/magic/GetObject/#magicgetobject","text":"This function allows you to convert a HitDetails into an object that you can interact with. The object returned from this function will usually expire immediately after any yield (the exception to this is the HitDetails from the Magic:GetSphereDetectionSignal function). This means that any effect that you want to apply to the object must be applied immediately after using Magic:GetObject . If you instead want a continuous reference to an object, consider using the Magic:GetLingeringObject function instead.","title":"Magic:GetObject"},{"location":"api/magic/GetObject/#parameters","text":"Name Type Default Description hitObjectDetails HitDetails The HitDetails of the object that you have detected.","title":"Parameters"},{"location":"api/magic/GetObject/#returns","text":"Return Type Summary Object The object that you retrieve from the HitDetails . This object will expire after any yield.","title":"Returns"},{"location":"api/magic/GetObject/#mana-cost","text":"This function does not currently cost any mana. local cost = 0 return cost","title":"Mana Cost"},{"location":"api/magic/GetSphereDetectionSignal/","text":"Magic:GetSphereDetectionSignal This function allows you to detect and use objects that are within a certain radius from a specified object. While the subscription is active, the returned RBXScriptSignal will fire for any object that enters or leaves the radius, giving you the HitDetails of that object. The HitDetails that is provided when an object enters the radius is different to normal HitDetails . You must use Magic:GetObject to get the object from this HitDetails (as opposed to Magic:GetLingeringObject ), and rather than expiring immediately, the object will only expire after it leaves the radius again. This allows you to use any object freely as long as it is within the radius of the detection sphere. Parameters Name Type Default Description detecting Object The position of this object is the centre of the detection sphere. radius float The radius of the detection sphere. Returns Return Type Summary Subscription When this subscription is cancelled, the RBXScriptSignal will no longer fire. RBXScriptSignal This event will fire every time an object enters or leaves the radius of the sphere. If fired when the object enters, any object retrieved from the HitDetails will expire when the object leaves the radius. If fired when the object leaves, the object retrieved from the HitDetails will act normally. Mana Mana is charged at a rate while the subscription is active. Code Samples The following code heals an object while it is within the detection sphere radius: local detectSub , detectionSignal = Magic : GetSphereDetectionSignal ( object ) detectionSignal : Connect ( function ( entered , hitDetails ) if entered then local detectedObject = Magic : GetObject ( hitDetails ) local healSub = Magic : Heal ( detectedObject , 10 ) --This subscription will be automatically cancelled when the object leaves the radius, as detectedObject will expire. end end )","title":"Magic:GetSphereDetectionSignal"},{"location":"api/magic/GetSphereDetectionSignal/#magicgetspheredetectionsignal","text":"This function allows you to detect and use objects that are within a certain radius from a specified object. While the subscription is active, the returned RBXScriptSignal will fire for any object that enters or leaves the radius, giving you the HitDetails of that object. The HitDetails that is provided when an object enters the radius is different to normal HitDetails . You must use Magic:GetObject to get the object from this HitDetails (as opposed to Magic:GetLingeringObject ), and rather than expiring immediately, the object will only expire after it leaves the radius again. This allows you to use any object freely as long as it is within the radius of the detection sphere.","title":"Magic:GetSphereDetectionSignal"},{"location":"api/magic/GetSphereDetectionSignal/#parameters","text":"Name Type Default Description detecting Object The position of this object is the centre of the detection sphere. radius float The radius of the detection sphere.","title":"Parameters"},{"location":"api/magic/GetSphereDetectionSignal/#returns","text":"Return Type Summary Subscription When this subscription is cancelled, the RBXScriptSignal will no longer fire. RBXScriptSignal This event will fire every time an object enters or leaves the radius of the sphere. If fired when the object enters, any object retrieved from the HitDetails will expire when the object leaves the radius. If fired when the object leaves, the object retrieved from the HitDetails will act normally.","title":"Returns"},{"location":"api/magic/GetSphereDetectionSignal/#mana","text":"Mana is charged at a rate while the subscription is active.","title":"Mana"},{"location":"api/magic/GetSphereDetectionSignal/#code-samples","text":"The following code heals an object while it is within the detection sphere radius: local detectSub , detectionSignal = Magic : GetSphereDetectionSignal ( object ) detectionSignal : Connect ( function ( entered , hitDetails ) if entered then local detectedObject = Magic : GetObject ( hitDetails ) local healSub = Magic : Heal ( detectedObject , 10 ) --This subscription will be automatically cancelled when the object leaves the radius, as detectedObject will expire. end end )","title":"Code Samples"},{"location":"api/object/","text":"Object All objects that you can manipulate with your magic are inherited from the Object class. Models, parts and characters are all examples of objects that you can use magic on. An object can either be classified as \"friendly\" if it belongs to you or one of your teammates, \"enemy\" if it belongs to a player on another team, or \"neutral\" otherwise. After a certain amount of time passes, an object will expire, and you can no longer call its methods or use it in the Magic class. The lifetime of an object is different depending on how it is obtained: If obtained from the Magic:GetObject function, the object will expire after any yield. If obtained from the Magic:GetLingeringObject function, the object will expire after the returned subscription is cancelled. Any objects will expire after they are destroyed. If the object belongs to you, it will not expire until it is destroyed. However, some HitDetails objects have an associated lifetime that will be used instead of the above conditions. For example, the HitDetails that is obtained from Magic:GetSphereDetectionSignal when entered is true will give an object that expires after the object leaves the radius, rather than after an amount of time. Functions float GetSize () Returns the size of the object based on its diagonal width. Vector3 GetDimensions() Returns the length, height and width of the object. Vector3 GetVelocity() CFrame GetCFrame() string GetName() bool IsType(string type) bool IsExpired() bool IsEnemy() bool IsFriendly() bool IsNeutral() bool IsMine() Object GetSubObject(string name) Gets a sub-object thats inside of the object (e.g. a part that is inside a model). AnimationTrack LoadAnimation(int animationID) Events Expiring -> (bool wasDestroyed) Touched -> ( HitDetails touchedObjectDetails)","title":"Object"},{"location":"api/object/#object","text":"All objects that you can manipulate with your magic are inherited from the Object class. Models, parts and characters are all examples of objects that you can use magic on. An object can either be classified as \"friendly\" if it belongs to you or one of your teammates, \"enemy\" if it belongs to a player on another team, or \"neutral\" otherwise. After a certain amount of time passes, an object will expire, and you can no longer call its methods or use it in the Magic class. The lifetime of an object is different depending on how it is obtained: If obtained from the Magic:GetObject function, the object will expire after any yield. If obtained from the Magic:GetLingeringObject function, the object will expire after the returned subscription is cancelled. Any objects will expire after they are destroyed. If the object belongs to you, it will not expire until it is destroyed. However, some HitDetails objects have an associated lifetime that will be used instead of the above conditions. For example, the HitDetails that is obtained from Magic:GetSphereDetectionSignal when entered is true will give an object that expires after the object leaves the radius, rather than after an amount of time.","title":"Object"},{"location":"api/object/#functions","text":"float GetSize () Returns the size of the object based on its diagonal width. Vector3 GetDimensions() Returns the length, height and width of the object. Vector3 GetVelocity() CFrame GetCFrame() string GetName() bool IsType(string type) bool IsExpired() bool IsEnemy() bool IsFriendly() bool IsNeutral() bool IsMine() Object GetSubObject(string name) Gets a sub-object thats inside of the object (e.g. a part that is inside a model). AnimationTrack LoadAnimation(int animationID)","title":"Functions"},{"location":"api/object/#events","text":"Expiring -> (bool wasDestroyed) Touched -> ( HitDetails touchedObjectDetails)","title":"Events"},{"location":"api/object/GetSize/","text":"Object:GetSize The size of an object is based on its diagonal width. The size of a default character is considered to be the average size of an object, and will return a value of 1. All other sizes are scaled accordingly (i.e. an object with twice the diagonal width of a character model will have a size of 2). The exact calculation for size is as follows: local characterDiagonalWidth = Vector3 . new ( 4 , 5 , 1 ). Magnitude local objectDiagonalWidth = object : GetDimensions (). Magnitude return objectDiagonalWidth / characterDiagonalWidth","title":"Object:GetSize"},{"location":"api/object/GetSize/#objectgetsize","text":"The size of an object is based on its diagonal width. The size of a default character is considered to be the average size of an object, and will return a value of 1. All other sizes are scaled accordingly (i.e. an object with twice the diagonal width of a character model will have a size of 2). The exact calculation for size is as follows: local characterDiagonalWidth = Vector3 . new ( 4 , 5 , 1 ). Magnitude local objectDiagonalWidth = object : GetDimensions (). Magnitude return objectDiagonalWidth / characterDiagonalWidth","title":"Object:GetSize"},{"location":"api/subscription/","text":"Subscription Subscription instances are returned from any function in the Magic class that charges mana at a continuous rate rather than a one-time payment. When a subscription is cancelled, you stop paying mana for that function, and the effect of the function is stopped. Subscriptions can be cancelled in one of four ways: You manually cancel the subscription with Subscription:Cancel() . If any of the objects you are using the function on expire, the subscription will be cancelled. If your mana runs out, all active subscriptions will be cancelled. When you reuse the same function on the same object, it will cancel the previous subscription. In this case, the overridden parameter of Subscription.Cancelled will be set to true. Functions void Cancel() Cancels the subscription, which ends the effect of the subscription and stops charging mana for the subscription. void CancelIn(duration) Cancels the subscription after the duration passes. bool IsCancelled() int GetRate() int GetTotalSpent() Events Cancelled -> (bool overridden) Fires when the subscription is cancelled for any reason. Overridden is true if it was cancelled by a new subscription that was created by the same function for the same object.","title":"Subscription"},{"location":"api/subscription/#subscription","text":"Subscription instances are returned from any function in the Magic class that charges mana at a continuous rate rather than a one-time payment. When a subscription is cancelled, you stop paying mana for that function, and the effect of the function is stopped. Subscriptions can be cancelled in one of four ways: You manually cancel the subscription with Subscription:Cancel() . If any of the objects you are using the function on expire, the subscription will be cancelled. If your mana runs out, all active subscriptions will be cancelled. When you reuse the same function on the same object, it will cancel the previous subscription. In this case, the overridden parameter of Subscription.Cancelled will be set to true.","title":"Subscription"},{"location":"api/subscription/#functions","text":"void Cancel() Cancels the subscription, which ends the effect of the subscription and stops charging mana for the subscription. void CancelIn(duration) Cancels the subscription after the duration passes. bool IsCancelled() int GetRate() int GetTotalSpent()","title":"Functions"},{"location":"api/subscription/#events","text":"Cancelled -> (bool overridden) Fires when the subscription is cancelled for any reason. Overridden is true if it was cancelled by a new subscription that was created by the same function for the same object.","title":"Events"},{"location":"articles/forcepriorities/","text":"Priority of Forces The forces applied by different Magic functions have differing priorities. If a force with a higher priority is applied to an object at the same time as a force with a lower priority, the lower priority force will be ignored. The basic priority order of movement forces from highest to lowest is as follows: Magic:Fling (with duration > 0) Magic:SetVelocity Magic:Translate Magic:SetAnchored Magic:Follow The priority order of rotational forces is as follows: Magic:Spin Magic:Watch Magic:PointTowards Magic:SetAnchored If two forces of the same priority are applied at the same time as each other by different players, it is handled differently depending on the force. Forces that charge mana with a subscription (like Magic:SetVelocity and Magic:Watch ) will establish a middle-ground between the conflicting instructions, calculating an average value to use. Forces with instantaneous costs are overridden by the player who used it last.","title":"Priority of Forces"},{"location":"articles/forcepriorities/#priority-of-forces","text":"The forces applied by different Magic functions have differing priorities. If a force with a higher priority is applied to an object at the same time as a force with a lower priority, the lower priority force will be ignored. The basic priority order of movement forces from highest to lowest is as follows: Magic:Fling (with duration > 0) Magic:SetVelocity Magic:Translate Magic:SetAnchored Magic:Follow The priority order of rotational forces is as follows: Magic:Spin Magic:Watch Magic:PointTowards Magic:SetAnchored If two forces of the same priority are applied at the same time as each other by different players, it is handled differently depending on the force. Forces that charge mana with a subscription (like Magic:SetVelocity and Magic:Watch ) will establish a middle-ground between the conflicting instructions, calculating an average value to use. Forces with instantaneous costs are overridden by the player who used it last.","title":"Priority of Forces"}]}